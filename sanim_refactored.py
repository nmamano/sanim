#!/usr/bin/env python

"""
Sanim: A simplified animation system built on top of manim.

This module provides tools to create animated presentations from simple text files.
It parses a specific syntax and converts it into manim animations.

Key Components:
- Parser: Converts text input into structured elements
- Elements: Different types of content (titles, text, bullets, etc.)
- Renderer: Handles the animation and positioning of elements

Usage:
    python extract_scene.py -x path/to/presentation.txt
"""

import os
import sys
import shutil

# Import manim components
from manim_engine.big_ol_pile_of_manim_imports import *

# Custom animation class
class CustomWrite(DrawBorderThenFill):
    """Custom animation for text with a unique reveal style."""
    CONFIG = {
        "rate_func": lambda t: smooth(1.5 * t - 0.5 * np.sin(t * np.pi)),
        "submobject_mode": "lagged_start",
        "stroke_color": "#333333",  # Darker stroke for better contrast
    }

    def __init__(self, mob_or_text, **kwargs):
        digest_config(self, kwargs)
        if isinstance(mob_or_text, str):
            mobject = TextMobject(mob_or_text)
        else:
            mobject = mob_or_text
        if "run_time" not in kwargs:
            self.establish_run_time(mobject)
        if "lag_factor" not in kwargs:
            if len(mobject.family_members_with_points()) < 4:
                min_lag_factor = 1
            else:
                min_lag_factor = 1.5
            self.lag_factor = max(self.run_time - 1, min_lag_factor)
        DrawBorderThenFill.__init__(self, mobject, **kwargs)

    def establish_run_time(self, mobject):
        num_subs = len(mobject.family_members_with_points())
        if num_subs < 15:
            self.run_time = 1.2  # Slightly slower for emphasis
        else:
            self.run_time = 2.2

# Constants for presentation styling
BACKGROUND_COLOR = "#e6f3ff"
DEFINITION_COLOR = "#991f00"

# Animation timing constants
DEFAULT_ANIMATION_RUNTIME = 0.8
FLUSH_ANIMATION_RUNTIME = 0.8
ELEMENT_DISPLAY_WAIT_TIME = 0.2
FLUSH_DISPLAY_WAIT_TIME = 0.2

# File path constants
SANIM_AUX_FILE = 'manim_engine' + os.sep + 'sanim_flag_AUTOGENERATED.txt'
SANIM_HTML_FILE = "sanim_interactive.html"
SANIM_LOCAL_HTML_FILE = "sanim_interactive_AUTOGENERATED.html"
SANIM_VIDEO_FILE = "vid"  # .mp4 extension is added automatically
SANIM_TIME_STAMPS_FILE = "time_stamps_AUTOGENERATED.js"

# Input syntax definitions
CONTENT_KEYWORDS = {"TITLE", "DEF", "-", "PLAIN", "IMAGE", "TERM"}
COMMAND_KEYWORDS = {"FLUSH"}
MODIFIER_SYMBOLS = {">", "^"}  # ^ is reserved for future use


# Exception classes
class SanimParseError(Exception):
    """Exception raised for errors in parsing the input file."""
    pass


class SanimRenderError(Exception):
    """Exception raised for errors in rendering the presentation."""
    pass


class ElementPosition:
    """
    Manages the position of elements in the presentation.
    """
    
    def __init__(self):
        """Initialize a new position tracker at the top-left corner."""
        self.position = self._get_top_left_position()
    
    def _get_top_left_position(self):
        """Create a mobject positioned at the top-left corner of the screen."""
        position = TextMobject("aux")  # Auxiliary object used only for positioning
        position.to_corner(TOP+LEFT, buff=MED_SMALL_BUFF)
        return position
    
    def get_current_position(self):
        """Get the current position mobject."""
        return self.position
    
    def reset_to_top(self):
        """Reset the position to the top-left corner."""
        self.position = self._get_top_left_position()
    
    def update_after_element(self, element):
        """
        Update position after adding an element.
        
        Args:
            element: The element that was just added
        """
        # Move to the bottom of the element
        self.position.move_to(element.get_bottom_position().get_edge_center(DOWN))
        # Add some vertical spacing
        self.position.shift(DOWN * 0.5)


class InputParser:
    """
    Parses input from a text file into structured elements.
    """
    
    @staticmethod
    def parse_file(file_path):
        """
        Parse a file into a list of InputLine objects.
        
        Args:
            file_path: Path to the input file
            
        Returns:
            List of InputLine objects
            
        Raises:
            SanimParseError: If there's an error parsing the file
        """
        try:
            with open(file_path, 'r') as f:
                lines = f.read().splitlines()
            
            result = []
            for i, line in enumerate(lines, 1):
                if line.strip():  # Skip empty lines
                    result.append(InputLine(i, line))
            return result
        except Exception as e:
            raise SanimParseError(f"Error parsing file {file_path}: {str(e)}")


class InputElement:
    """
    Represents a single element from the input file.
    """
    
    def __init__(self, raw_content):
        """
        Initialize a new InputElement from raw text.
        
        Args:
            raw_content: Raw text content from the input file
            
        Raises:
            SanimParseError: If there's an error parsing the element
        """
        if ';' in raw_content:
            raise SanimParseError('Input element cannot contain ";"')
        
        # Store original content
        self.raw_content = raw_content[:]
        
        # Parse modifiers (>, ^, etc.)
        self.modifiers = []
        i = 0
        while i < len(raw_content) and (raw_content[i] == ' ' or raw_content[i] in MODIFIER_SYMBOLS):
            if raw_content[i] in MODIFIER_SYMBOLS:
                self.modifiers.append(raw_content[i])
            i += 1
        
        # Skip trailing whitespace after modifiers
        while i < len(raw_content) and raw_content[i] == ' ':
            i += 1
        
        # Parse keyword and content
        remaining_content = raw_content[i:]
        if not remaining_content:
            # Empty content
            self.keyword = "PLAIN"
            self.content = ""
            if '>' not in self.modifiers:
                self.modifiers.append('>')  # Never wait for empty input
            self.keyword_type = 'content'
            return
        
        # Extract the keyword
        space_index = remaining_content.find(' ')
        if space_index == -1:
            # No space - the entire string might be a keyword
            potential_keyword = remaining_content
            self.content = ""
        else:
            potential_keyword = remaining_content[:space_index]
            self.content = remaining_content[space_index+1:]
        
        # Check if it's a valid keyword
        if potential_keyword in CONTENT_KEYWORDS or potential_keyword in COMMAND_KEYWORDS:
            self.keyword = potential_keyword
        else:
            # Not a keyword, treat as plain text
            self.keyword = "PLAIN"
            self.content = remaining_content
            
        self.keyword_type = 'content' if self.keyword in CONTENT_KEYWORDS else 'command'
    
    def should_wait_for_input(self):
        """
        Check if this element should wait for user input after displaying.
        
        Returns:
            True if the element should wait for input, False otherwise
        """
        return '>' not in self.modifiers


class InputLine:
    """
    Represents a line from the input file.
    """
    
    def __init__(self, line_num, raw_content):
        """
        Initialize a new InputLine from raw text.
        
        Args:
            line_num: Line number in the source file
            raw_content: Raw text content from the input file
        """
        self.line_num = line_num
        self.raw_content = raw_content[:]
        
        # Split by semicolons
        self.raw_input_elements = raw_content.split(';')
        self.input_elements = [InputElement(elem) for elem in self.raw_input_elements]
        
        # Convert input elements to output elements
        self.output_elements = []
        for elem in self.input_elements:
            if elem.keyword == "TITLE":
                self.output_elements.append(TitleElement(elem))
            elif elem.keyword == "PLAIN":
                self.output_elements.append(PlainTextElement(elem))
            elif elem.keyword == "-":
                self.output_elements.append(BulletElement(elem))
            elif elem.keyword == "DEF":
                self.output_elements.append(DefinitionElement(elem))
            elif elem.keyword == "IMAGE":
                self.output_elements.append(ImageElement(elem))
            elif elem.keyword == "TERM":
                self.output_elements.append(TermElement(elem))
    
    def is_content_line(self):
        """Check if this line contains content elements."""
        return bool(self.output_elements)
    
    def get_fade_out_actions(self):
        """Get animations to fade out all elements in this line."""
        result = []
        for elem in self.output_elements:
            result.extend(elem.get_fade_out_actions())
        return result


class OutputElement:
    """
    Base class for all output elements.
    """
    
    def __init__(self, input_elem):
        """
        Initialize a new OutputElement.
        
        Args:
            input_elem: The input element this output element is based on
        """
        self.input_elem = input_elem
        self.wait_for_input = input_elem.should_wait_for_input()
    
    def individual_play(self, scene):
        """
        Animate the element in the scene.
        
        Args:
            scene: The scene to animate in
        """
        raise NotImplementedError("Subclasses must implement this method")
    
    def get_play_actions(self):
        """
        Get the animations to play this element.
        
        Returns:
            List of animations to play
        """
        raise NotImplementedError("Subclasses must implement this method")
    
    def individual_play_duration(self):
        """
        Get the duration of this element's animation.
        
        Returns:
            Animation duration in seconds
        """
        raise NotImplementedError("Subclasses must implement this method")
    
    def position_center_at(self, position):
        """
        Position this element centered at the given position.
        
        Args:
            position: The position to center at
        """
        raise NotImplementedError("Subclasses must implement this method")
    
    def position_left_aligned(self, position):
        """
        Position this element left-aligned at the given position.
        
        Args:
            position: The position to align to
        """
        raise NotImplementedError("Subclasses must implement this method")
    
    def get_shift_center_at_actions(self, position):
        """
        Get animations to shift this element to be centered at the given position.
        
        Args:
            position: The position to center at
            
        Returns:
            List of animations to play
        """
        raise NotImplementedError("Subclasses must implement this method")
    
    def get_shift_left_aligned_actions(self, position):
        """
        Get animations to shift this element to be left-aligned at the given position.
        
        Args:
            position: The position to align to
            
        Returns:
            List of animations to play
        """
        raise NotImplementedError("Subclasses must implement this method")
    
    def get_bottom_position(self):
        """
        Get the position at the bottom of this element.
        
        Returns:
            Mobject representing the bottom position
        """
        raise NotImplementedError("Subclasses must implement this method")
    
    def get_fade_out_actions(self):
        """
        Get animations to fade out this element.
        
        Returns:
            List of animations to play
        """
        raise NotImplementedError("Subclasses must implement this method")
    
    def copy(self):
        """
        Create a copy of this element.
        
        Returns:
            A new instance of this element
        """
        raise NotImplementedError("Subclasses must implement this method")


class TitleElement(OutputElement):
    """Element representing a title in the presentation."""
    
    def __init__(self, input_elem):
        """
        Initialize a new TitleElement.
        
        Args:
            input_elem: The input element this output element is based on
            
        Raises:
            SanimParseError: If the title is empty
        """
        super().__init__(input_elem)
        content = input_elem.content
        if not content:
            raise SanimParseError('Empty title')
        
        # Calculate runtime based on content length
        self.run_time = 1.1 + len(content) / 200
        
        # Create the title mobject
        self.text = Title(
            content, 
            scale_factor=1.3, 
            color=BLACK, 
            background_stroke_color=BACKGROUND_COLOR
        )
    
    def copy(self):
        """Create a copy of this element."""
        return TitleElement(self.input_elem)
    
    def individual_play(self, scene):
        """Animate the title in the scene."""
        scene.play(CustomWrite(self.text), run_time=self.run_time)
    
    def get_play_actions(self):
        """Get the animations to play this title."""
        return [CustomWrite(self.text)]
    
    def individual_play_duration(self):
        """Get the duration of this title's animation."""
        return self.run_time
    
    def position_center_at(self, position):
        """Position this title centered at the given position."""
        self.text.move_to(position)
    
    def position_left_aligned(self, position):
        """Position this title at the top of the screen."""
        self.text.center()
        self.text.to_edge(UP)
    
    def get_shift_center_at_actions(self, position):
        """Get animations to shift this title to be centered at the given position."""
        return [ApplyMethod(self.text.move_to, position)]
    
    def get_shift_left_aligned_actions(self, position):
        """Get animations to shift this title to be left-aligned at the given position."""
        # Create a temporary position
        pos_title = TextMobject("aux")
        pos_title.center()
        pos_title.to_edge(UP)
        return [ApplyMethod(self.text.move_to, pos_title)]
    
    def get_bottom_position(self):
        """Get the position at the bottom of this title."""
        return self.text
    
    def get_fade_out_actions(self):
        """Get animations to fade out this title."""
        return [FadeOut(self.text)]


class PlainTextElement(OutputElement):
    """Element representing plain text in the presentation."""
    
    def __init__(self, input_elem):
        """
        Initialize a new PlainTextElement.
        
        Args:
            input_elem: The input element this output element is based on
        """
        super().__init__(input_elem)
        content = input_elem.content
        
        if not content:
            # Empty text - create an invisible placeholder
            self.text = TextMobject(
                "aux",  # This is never displayed but used for positioning
                color=BLACK,
                background_stroke_color=BACKGROUND_COLOR
            )
            self.run_time = 0
            self.is_empty = True
        else:
            # Regular text
            self.text = TextMobject(
                content, 
                color=BLACK, 
                background_stroke_color=BACKGROUND_COLOR
            )
            self.run_time = 0.6 + len(content) / 150
            self.is_empty = False
    
    def copy(self):
        """Create a copy of this element."""
        return PlainTextElement(self.input_elem)
    
    def individual_play(self, scene):
        """Animate the text in the scene."""
        if not self.is_empty:
            scene.play(CustomWrite(self.text), run_time=self.run_time)
    
    def get_play_actions(self):
        """Get the animations to play this text."""
        if self.is_empty:
            return []
        return [CustomWrite(self.text)]
    
    def individual_play_duration(self):
        """Get the duration of this text's animation."""
        return self.run_time
    
    def position_center_at(self, position):
        """Position this text centered at the given position."""
        self.text.move_to(position)
    
    def position_left_aligned(self, position):
        """Position this text left-aligned at the given position."""
        self.text.move_to(position)
        self.text.to_edge(LEFT)
    
    def get_shift_center_at_actions(self, position):
        """Get animations to shift this text to be centered at the given position."""
        if self.is_empty:
            return []
        return [ApplyMethod(self.text.move_to, position)]
    
    def get_shift_left_aligned_actions(self, position):
        """Get animations to shift this text to be left-aligned at the given position."""
        if self.is_empty:
            return []
        
        # Create a temporary mobject for positioning
        pos_text = TextMobject("aux")
        pos_text.move_to(position)
        pos_text.to_edge(LEFT)
        
        return [ApplyMethod(self.text.move_to, pos_text)]
    
    def get_bottom_position(self):
        """Get the position at the bottom of this text."""
        return self.text
    
    def get_fade_out_actions(self):
        """Get animations to fade out this text."""
        if self.is_empty:
            return []
        return [FadeOut(self.text)]


class BulletElement(OutputElement):
    """Element representing a bullet point in the presentation."""
    
    def __init__(self, input_elem):
        """
        Initialize a new BulletElement.
        
        Args:
            input_elem: The input element this output element is based on
            
        Raises:
            SanimParseError: If the bullet content is empty
        """
        super().__init__(input_elem)
        content = input_elem.content
        if not content:
            raise SanimParseError("Empty bullet item")
        
        # Create the bullet mobject
        self.text = BulletedItem(
            content, 
            color=BLACK, 
            background_stroke_color=BACKGROUND_COLOR
        )
        self.run_time = 0.6 + len(content) / 150
    
    def copy(self):
        """Create a copy of this element."""
        return BulletElement(self.input_elem)
    
    def individual_play(self, scene):
        """Animate the bullet in the scene."""
        scene.play(CustomWrite(self.text), run_time=self.run_time)
    
    def get_play_actions(self):
        """Get the animations to play this bullet."""
        return [CustomWrite(self.text)]
    
    def individual_play_duration(self):
        """Get the duration of this bullet's animation."""
        return self.run_time
    
    def position_center_at(self, position):
        """Position this bullet centered at the given position."""
        self.text.move_to(position)
    
    def position_left_aligned(self, position):
        """Position this bullet left-aligned at the given position."""
        self.text.move_to(position)
        self.text.to_edge(LEFT)
    
    def get_shift_center_at_actions(self, position):
        """Get animations to shift this bullet to be centered at the given position."""
        return [ApplyMethod(self.text.move_to, position)]
    
    def get_shift_left_aligned_actions(self, position):
        """Get animations to shift this bullet to be left-aligned at the given position."""
        # Create a temporary mobject for positioning
        pos_text = BulletedItem(self.input_elem.content)
        pos_text.move_to(position)
        pos_text.to_edge(LEFT)
        
        return [ApplyMethod(self.text.move_to, pos_text)]
    
    def get_bottom_position(self):
        """Get the position at the bottom of this bullet."""
        return self.text
    
    def get_fade_out_actions(self):
        """Get animations to fade out this bullet."""
        return [FadeOut(self.text)]


class DefinitionElement(OutputElement):
    """Element representing a definition (term and explanation) in the presentation."""
    
    def __init__(self, input_elem):
        """
        Initialize a new DefinitionElement.
        
        Args:
            input_elem: The input element this output element is based on
            
        Raises:
            SanimParseError: If the definition syntax is invalid
        """
        super().__init__(input_elem)
        content = input_elem.content.lstrip()
        
        # Parse term and definition
        if not content or content[0] != '"':
            raise SanimParseError('Invalid use of DEF. Syntax: DEF "term" definition')
        
        content = content[1:]
        if '"' not in content:
            raise SanimParseError('Invalid use of DEF. Syntax: DEF "term" definition')
        
        # Extract term and definition text
        self.term_text = content[:content.find('"')]
        self.definition_text = content[content.find('"')+1:].lstrip()
        
        if not self.term_text:
            raise SanimParseError('Empty term in DEF')
        if not self.definition_text:
            raise SanimParseError('Empty definition in DEF')
        
        # Create term and definition mobjects
        self.term = TextMobject(
            '\\textbf{' + self.term_text + '}:',
            background_stroke_color=BACKGROUND_COLOR, 
            alignment=""
        )
        self.term.set_color(DEFINITION_COLOR)
        
        self.definition = TextMobject(
            self.definition_text,
            color=BLACK, 
            background_stroke_color=BACKGROUND_COLOR, 
            alignment=""
        )
        
        # Animation timing
        self.term_run_time = 0.5
        self.in_between_time = 0.1
        self.definition_run_time = 0.6 + len(self.definition_text) / 150
    
    def copy(self):
        """Create a copy of this element."""
        return DefinitionElement(self.input_elem)
    
    def individual_play(self, scene):
        """Animate the definition in the scene."""
        scene.play(CustomWrite(self.term), run_time=self.term_run_time)
        scene.wait(self.in_between_time)
        scene.play(CustomWrite(self.definition), run_time=self.definition_run_time)
    
    def get_play_actions(self):
        """Get the animations to play this definition."""
        return [CustomWrite(self.term), CustomWrite(self.definition)]
    
    def individual_play_duration(self):
        """Get the duration of this definition's animation."""
        return self.term_run_time + self.in_between_time + self.definition_run_time
    
    def position_center_at(self, position):
        """Position this definition centered at the given position."""
        self.term.move_to(position)
        self.definition.next_to(self.term, RIGHT)
        self.definition.align_to(self.term, UP)
    
    def position_left_aligned(self, position):
        """Position this definition left-aligned at the given position."""
        self.term.move_to(position)
        self.term.to_edge(LEFT)
        self.definition.next_to(self.term, RIGHT)
        self.definition.align_to(self.term, UP)
    
    def get_shift_center_at_actions(self, position):
        """Get animations to shift this definition to be centered at the given position."""
        # Create temporary mobjects for positioning
        pos_term = TextMobject(self.term_text, alignment="")
        pos_definition = TextMobject(self.definition_text, alignment="")
        
        pos_term.move_to(position)
        pos_definition.next_to(pos_term, RIGHT)
        pos_definition.align_to(pos_term, UP)
        
        return [
            ApplyMethod(self.term.move_to, pos_term),
            ApplyMethod(self.definition.move_to, pos_definition)
        ]
    
    def get_shift_left_aligned_actions(self, position):
        """Get animations to shift this definition to be left-aligned at the given position."""
        # Create temporary mobjects for positioning
        pos_term = TextMobject(self.term_text, alignment="")
        pos_definition = TextMobject(self.definition_text, alignment="")
        
        pos_term.move_to(position)
        pos_term.to_edge(LEFT)
        pos_definition.next_to(pos_term, RIGHT)
        pos_definition.align_to(pos_term, UP)
        
        return [
            ApplyMethod(self.term.move_to, pos_term),
            ApplyMethod(self.definition.move_to, pos_definition)
        ]
    
    def get_bottom_position(self):
        """Get the position at the bottom of this definition."""
        return self.definition
    
    def get_fade_out_actions(self):
        """Get animations to fade out this definition."""
        return [FadeOut(self.term), FadeOut(self.definition)]


class TermElement(OutputElement):
    """Element representing a term in the presentation."""
    
    def __init__(self, input_elem):
        """
        Initialize a new TermElement.
        
        Args:
            input_elem: The input element this output element is based on
            
        Raises:
            SanimParseError: If the term syntax is invalid
        """
        super().__init__(input_elem)
        content = input_elem.content.lstrip()
        
        # Parse term
        if not content or content[0] != '"':
            raise SanimParseError('Invalid use of TERM. Syntax: TERM "term"')
        
        content = content[1:]
        if '"' not in content:
            raise SanimParseError('Invalid use of TERM. Syntax: TERM "term"')
        
        # Extract term text
        self.term_text = content[:content.find('"')]
        
        if not self.term_text:
            raise SanimParseError('Empty term in TERM')
        
        # Create term mobject
        self.term = TextMobject(
            '\\textbf{' + self.term_text + '}',
            background_stroke_color=BACKGROUND_COLOR, 
            alignment=""
        )
        
        # Animation timing
        self.term_run_time = 0.5
    
    def copy(self):
        """Create a copy of this element."""
        return TermElement(self.input_elem)
    
    def individual_play(self, scene):
        """Animate the term in the scene."""
        scene.play(CustomWrite(self.term), run_time=self.term_run_time)
    
    def get_play_actions(self):
        """Get the animations to play this term."""
        return [CustomWrite(self.term)]
    
    def individual_play_duration(self):
        """Get the duration of this term's animation."""
        return self.term_run_time
    
    def position_center_at(self, position):
        """Position this term centered at the given position."""
        self.term.move_to(position)
    
    def position_left_aligned(self, position):
        """Position this term left-aligned at the given position."""
        self.term.move_to(position)
        self.term.to_edge(LEFT)
    
    def get_shift_center_at_actions(self, position):
        """Get animations to shift this term to be centered at the given position."""
        return [ApplyMethod(self.term.move_to, position)]
    
    def get_shift_left_aligned_actions(self, position):
        """Get animations to shift this term to be left-aligned at the given position."""
        # Create a temporary mobject for positioning
        pos_term = TextMobject(self.term_text, alignment="")
        pos_term.move_to(position)
        pos_term.to_edge(LEFT)
        
        return [ApplyMethod(self.term.move_to, pos_term)]
    
    def get_bottom_position(self):
        """Get the position at the bottom of this term."""
        return self.term
    
    def get_fade_out_actions(self):
        """Get animations to fade out this term."""
        return [FadeOut(self.term)]


class ImageElement(OutputElement):
    """Element representing an image in the presentation."""
    
    def __init__(self, input_elem):
        """
        Initialize a new ImageElement.
        
        Args:
            input_elem: The input element this output element is based on
            
        Raises:
            SanimParseError: If the image path is empty
            SanimRenderError: If the image can't be loaded
        """
        super().__init__(input_elem)
        
        # Parse input to extract path and optional height
        content_parts = input_elem.content.strip().split()
        if not content_parts:
            raise SanimParseError('Empty image path')
        
        image_path = content_parts[0]
        
        # Optional height parameter
        image_height = 4.0  # Default height
        if len(content_parts) > 1:
            try:
                image_height = float(content_parts[1])
            except ValueError:
                pass  # Ignore invalid height values
        
        try:
            # Load the image
            self.image = ImageMobject(image_path)
            
            # Set the height as specified
            self.image.stretch_to_fit_height(image_height)
            
            # Runtime based on a constant value
            self.run_time = 0.8
        except Exception as e:
            raise SanimRenderError(f"Failed to load image {image_path}: {str(e)}")
    
    def copy(self):
        """Create a copy of this element."""
        return ImageElement(self.input_elem)
    
    def individual_play(self, scene):
        """Animate the image in the scene."""
        scene.play(FadeIn(self.image), run_time=self.run_time)
    
    def get_play_actions(self):
        """Get the animations to play this image."""
        return [FadeIn(self.image)]
    
    def individual_play_duration(self):
        """Get the duration of this image's animation."""
        return self.run_time
    
    def position_center_at(self, position):
        """Position this image centered at the given position."""
        self.image.move_to(position)
    
    def position_left_aligned(self, position):
        """
        Position this image at the given position, aligned with the top.
        
        This ensures the image appears below previous content, not overlapping.
        """
        # First align the top of the image with the current position
        self.image.move_to(position)
        
        # Align the top edge of the image with the position
        current_top = self.image.get_top()
        target_top = position.get_center() + UP * 0.1  # Small buffer
        self.image.shift(target_top - current_top)
        
        # Center horizontally in the frame
        center_x = ORIGIN[0]  # X-coordinate of the center of the screen
        current_x = self.image.get_center()[0]  # Current X-coordinate of the image
        self.image.shift(RIGHT * (center_x - current_x))
    
    def get_shift_center_at_actions(self, position):
        """Get animations to shift this image to be centered at the given position."""
        return [ApplyMethod(self.image.move_to, position)]
    
    def get_shift_left_aligned_actions(self, position):
        """Get animations to shift this image to be left-aligned at the given position."""
        # Create a target position object for positioning
        temp_image = self.image.copy()  # Used only for positioning
        
        # First align the top with current position (to avoid overlap)
        temp_image.move_to(position)
        current_top = temp_image.get_top()
        target_top = position.get_center() + UP * 0.1  # Small buffer
        temp_image.shift(target_top - current_top)
        
        # Center horizontally in the frame
        center_x = ORIGIN[0]  # X-coordinate of the center of the screen
        current_x = temp_image.get_center()[0]  # Current X-coordinate
        temp_image.shift(RIGHT * (center_x - current_x))
        
        return [ApplyMethod(self.image.move_to, temp_image)]
    
    def get_bottom_position(self):
        """Get the position at the bottom of this image."""
        return self.image
    
    def get_fade_out_actions(self):
        """Get animations to fade out this image."""
        return [FadeOut(self.image)]


class AnimationBuffer:
    """
    Manages a buffer of animations to be played together.
    """
    
    def __init__(self, scene):
        """
        Initialize a new animation buffer.
        
        Args:
            scene: The scene to play animations in
        """
        self.scene = scene
        self.buffer = []
        self.time_stamps = []
    
    def add_element(self, element):
        """
        Add an element to the animation buffer.
        
        If the element should wait for input, the buffer is flushed before
        adding the element.
        
        Args:
            element: The element to add
        """
        if element.wait_for_input:
            self.flush()
        self.buffer.append(element)
    
    def flush(self):
        """
        Play all animations in the buffer and clear it.
        """
        if not self.buffer:
            return
        
        if len(self.buffer) == 1:
            # Play a single element
            element = self.buffer[0]
            element.individual_play(self.scene)
        else:
            # Play multiple elements together
            actions = []
            for element in self.buffer:
                actions.extend(element.get_play_actions())
            self.scene.play(*actions, run_time=DEFAULT_ANIMATION_RUNTIME)
        
        # Clear the buffer
        self.buffer.clear()
        
        # Record timestamp for the web player
        self.time_stamps.append(self.scene.current_scene_time + ELEMENT_DISPLAY_WAIT_TIME / 2)
        self.scene.wait(ELEMENT_DISPLAY_WAIT_TIME)
    
    def get_time_stamps(self):
        """
        Get the timestamps of all animations.
        
        Returns:
            List of timestamps in seconds
        """
        return self.time_stamps


class PresentationRenderer:
    """
    Renders a presentation from InputLines.
    """
    
    def __init__(self, scene):
        """
        Initialize a new presentation renderer.
        
        Args:
            scene: The scene to render in
        """
        self.scene = scene
        self.position = ElementPosition()
        self.animation_buffer = AnimationBuffer(scene)
    
    def render_line(self, line):
        """
        Render a line of content.
        
        Args:
            line: The line to render
        """
        elements = line.output_elements
        
        if len(elements) == 1:
            # Single element - left aligned
            element = elements[0]
            element.position_left_aligned(self.position.get_current_position())
            self.position.update_after_element(element)
            self.animation_buffer.add_element(element)
        else:
            # Multiple elements - distribute horizontally
            num_elements = len(elements)
            for i, element in enumerate(elements, 1):
                # Create a position for this element
                position = self.position.get_current_position()
                position.to_edge(LEFT, buff=0)
                position.shift(RIGHT * (position.get_edge_center(LEFT) - position.get_center()))
                position.shift(i * 2 * FRAME_X_RADIUS * RIGHT / (num_elements + 1))
                
                # Position and animate the element
                element.position_center_at(position)
                self.animation_buffer.add_element(element)
            
            # Update position to the bottom of the last element
            self.position.update_after_element(elements[-1])
    
    def get_shift_actions(self, line, position):
        """
        Get animations to shift elements in a line to a new position.
        
        Args:
            line: The line to shift
            position: The new position
            
        Returns:
            List of animations to play
        """
        elements = line.output_elements
        result = []
        
        if not elements:
            return []
        
        if len(elements) == 1:
            # Single element - left aligned
            element = elements[0]
            result.extend(element.get_shift_left_aligned_actions(position))
            
            # Update position
            element_copy = element.copy()
            element_copy.position_left_aligned(position)
            position.move_to(element_copy.get_bottom_position().get_edge_center(DOWN))
        else:
            # Multiple elements - distribute horizontally
            num_elements = len(elements)
            for i, element in enumerate(elements, 1):
                # Create a position for this element
                elem_position = position.copy()
                elem_position.to_edge(LEFT, buff=0)
                elem_position.shift(RIGHT * (elem_position.get_edge_center(LEFT) - elem_position.get_center()))
                elem_position.shift(i * 2 * FRAME_X_RADIUS * RIGHT / (num_elements + 1))
                
                # Get shift actions
                result.extend(element.get_shift_center_at_actions(elem_position))
            
            # Update position
            element_copy = elements[-1].copy()
            element_copy.position_center_at(elem_position)
            position.move_to(element_copy.get_bottom_position().get_edge_center(DOWN))
        
        # Add some vertical spacing
        position.shift(DOWN * 0.5)
        return result
    
    def render_presentation(self, lines):
        """
        Render a complete presentation.
        
        Args:
            lines: List of input lines to render
            
        Returns:
            List of timestamps for the web player
        """
        flush_index = 0  # Starting line to flush when using FLUSH
        
        # Initial wait
        self.scene.wait(ELEMENT_DISPLAY_WAIT_TIME)
        self.animation_buffer.time_stamps = [ELEMENT_DISPLAY_WAIT_TIME / 2]  # Initial timestamp
        
        for line in lines:
            if line.is_content_line():
                # Render content line
                self.render_line(line)
            else:
                # Process command line
                elements = line.input_elements
                if not elements:
                    raise SanimParseError("Empty line")
                if len(elements) > 1:
                    raise SanimParseError("More than one command in a line")
                
                element = elements[0]
                if element.keyword == 'FLUSH':
                    # Flush command
                    self.animation_buffer.flush()  # Flush any leftover animations
                    
                    # Parse flush line number (if empty, use the current line)
                    try:
                        if element.content.strip():
                            flush_line_num = int(element.content)
                        else:
                            flush_line_num = line.line_num
                    except ValueError:
                        raise SanimParseError(f"Invalid flush line number: {element.content}")
                    
                    current_line_num = line.line_num
                    if flush_line_num > current_line_num:
                        raise SanimParseError("Cannot flush beyond the current line")
                    
                    # Collect fade out animations for lines to be flushed
                    fade_out_actions = []
                    while flush_index < len(lines) and lines[flush_index].line_num < flush_line_num:
                        if lines[flush_index].is_content_line():
                            fade_out_actions.extend(lines[flush_index].get_fade_out_actions())
                        flush_index += 1
                    
                    # Reset position to top
                    self.position.reset_to_top()
                    
                    # Collect shift animations for lines to be kept
                    shift_actions = []
                    i = flush_index
                    current_position = self.position.get_current_position()
                    while i < len(lines) and lines[i].line_num < current_line_num:
                        shift_actions.extend(self.get_shift_actions(
                            lines[i], current_position))
                        i += 1
                    
                    # Play flush animations
                    if fade_out_actions or shift_actions:
                        self.scene.play(
                            *fade_out_actions, *shift_actions, 
                            run_time=FLUSH_ANIMATION_RUNTIME
                        )
                    
                    # Record timestamp and wait
                    self.animation_buffer.time_stamps.append(
                        self.scene.current_scene_time + FLUSH_DISPLAY_WAIT_TIME / 2
                    )
                    self.scene.wait(FLUSH_DISPLAY_WAIT_TIME)
                else:
                    raise SanimParseError(f"Unknown command: {element.keyword}")
        
        # Flush any remaining animations
        self.animation_buffer.flush()
        
        return self.animation_buffer.get_time_stamps()


class Sanim(Scene):
    """
    Main Sanim scene class for rendering presentations.
    """
    
    CONFIG = {
        "camera_config": {"background_color": BACKGROUND_COLOR}
    }
    
    def construct(self):
        """Construct the scene for the presentation."""
        try:
            # Read the source file path from the auxiliary file
            with open(SANIM_AUX_FILE, "r") as sanim_file:
                source_file = sanim_file.read().strip()
            
            # Parse the input file
            lines = InputParser.parse_file(source_file)
            print("Finished parsing")
            
            # Render the presentation
            renderer = PresentationRenderer(self)
            time_stamps = renderer.render_presentation(lines)
            
            # Save timestamp data for the web player
            self._save_web_player_data(source_file, time_stamps)
            
        except SanimParseError as e:
            print(f"Error parsing input: {str(e)}")
            sys.exit(1)
        except SanimRenderError as e:
            print(f"Error rendering presentation: {str(e)}")
            sys.exit(1)
        except Exception as e:
            import traceback
            print(f"Unexpected error: {str(e)}")
            traceback.print_exc()
            sys.exit(1)
    
    def _save_web_player_data(self, source_file, time_stamps):
        """
        Save data for the web player.
        
        Args:
            source_file: Path to the source file
            time_stamps: List of timestamps
        """
        try:
            # Get source directory
            source_folder = os.path.dirname(os.path.abspath(source_file))
            
            # Save timestamps
            web_info_file = os.path.join(source_folder, SANIM_TIME_STAMPS_FILE)
            with open(web_info_file, 'w') as web_file:
                web_file.write(f"var timeStamps = {[round(t, 4) for t in time_stamps]}\n")
            
            # Copy HTML template
            source_html = os.path.join(self._get_main_manim_dir(), SANIM_HTML_FILE)
            dest_html = os.path.join(source_folder, SANIM_LOCAL_HTML_FILE)
            try:
                shutil.copy2(source_html, dest_html)
            except Exception as e:
                print(f"Error copying HTML template: {e}")
                try:
                    # Attempt to clean up
                    os.remove(dest_html)
                except Exception:
                    pass
        except Exception as e:
            print(f"Error saving web player data: {e}")
    
    def _get_main_manim_dir(self):
        """
        Get the main manim directory.
        
        Returns:
            Path to the main manim directory
        """
        # Find the directory containing the module
        # This is the directory containing sanim_refactored.py
        module_dir = os.path.dirname(os.path.abspath(__file__))
        return module_dir


# Utility functions for compatibility with the original sanim.py

def get_sanim_source_dir():
    """
    Get the directory containing the sanim source file.
    
    Returns:
        Path to the sanim source directory
    """
    with open(SANIM_AUX_FILE, "r") as sanim_file:
        source_file = sanim_file.read().strip()
    return os.path.dirname(os.path.abspath(source_file))


def get_main_manim_dir():
    """
    Get the main manim directory.
    
    Returns:
        Path to the main manim directory
    """
    # Find the directory containing the module
    module_dir = os.path.dirname(os.path.abspath(__file__))
    return module_dir