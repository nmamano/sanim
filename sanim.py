#!/usr/bin/env python

"""
Sanim: A simplified animation system built on top of manim.

This module provides tools to create animated presentations from simple text files.
It parses a specific syntax and converts it into manim animations.

Key Components:
- Parser: Converts text input into structured elements
- Elements: Different types of content (titles, text, bullets, etc.)
- Renderer: Handles the animation and positioning of elements

Usage:
    python extract_scene.py -x path/to/presentation.txt
"""

import os
import sys
import shutil

# Import manim components
from manim_engine.big_ol_pile_of_manim_imports import *

# Import utility modules
from util.parsing import (
    InputParser, InputLine, InputElement, ElementPosition,
    SanimParseError, SanimRenderError
)

# Import element classes
from elements.base import OutputElement
from elements.text import (
    TitleElement, PlainTextElement, BulletElement, 
    DefinitionElement, TermElement
)
from elements.media import ImageElement

# Custom animation class
class CustomWrite(DrawBorderThenFill):
    """Custom animation for text with a unique reveal style."""
    CONFIG = {
        "rate_func": lambda t: smooth(1.5 * t - 0.5 * np.sin(t * np.pi)),
        "submobject_mode": "lagged_start",
        "stroke_color": "#333333",  # Darker stroke for better contrast
    }

    def __init__(self, mob_or_text, **kwargs):
        digest_config(self, kwargs)
        if isinstance(mob_or_text, str):
            mobject = TextMobject(mob_or_text)
        else:
            mobject = mob_or_text
        if "run_time" not in kwargs:
            self.establish_run_time(mobject)
        if "lag_factor" not in kwargs:
            if len(mobject.family_members_with_points()) < 4:
                min_lag_factor = 1
            else:
                min_lag_factor = 1.5
            self.lag_factor = max(self.run_time - 1, min_lag_factor)
        DrawBorderThenFill.__init__(self, mobject, **kwargs)

    def establish_run_time(self, mobject):
        num_subs = len(mobject.family_members_with_points())
        if num_subs < 15:
            self.run_time = 1.2  # Slightly slower for emphasis
        else:
            self.run_time = 2.2

# Constants for presentation styling
BACKGROUND_COLOR = "#e6f3ff"
DEFINITION_COLOR = "#991f00"

# Animation timing constants
DEFAULT_ANIMATION_RUNTIME = 0.8
FLUSH_ANIMATION_RUNTIME = 0.8
ELEMENT_DISPLAY_WAIT_TIME = 0.2
FLUSH_DISPLAY_WAIT_TIME = 0.2

# File path constants
SANIM_AUX_FILE = 'manim_engine' + os.sep + 'sanim_flag_AUTOGENERATED.txt'
SANIM_HTML_FILE = "sanim_interactive.html"
SANIM_LOCAL_HTML_FILE = "sanim_interactive_AUTOGENERATED.html"
SANIM_VIDEO_FILE = "vid"  # .mp4 extension is added automatically
SANIM_TIME_STAMPS_FILE = "time_stamps_AUTOGENERATED.js"


class AnimationBuffer:
    """
    Manages a buffer of animations to be played together.
    """
    
    def __init__(self, scene):
        """
        Initialize a new animation buffer.
        
        Args:
            scene: The scene to play animations in
        """
        self.scene = scene
        self.buffer = []
        self.time_stamps = []
    
    def add_element(self, element):
        """
        Add an element to the animation buffer.
        
        If the element should wait for input, the buffer is flushed before
        adding the element.
        
        Args:
            element: The element to add
        """
        if element.wait_for_input:
            self.flush()
        self.buffer.append(element)
    
    def flush(self):
        """
        Play all animations in the buffer and clear it.
        """
        if not self.buffer:
            return
        
        if len(self.buffer) == 1:
            # Play a single element
            element = self.buffer[0]
            element.individual_play(self.scene)
        else:
            # Play multiple elements together
            actions = []
            for element in self.buffer:
                actions.extend(element.get_play_actions())
            self.scene.play(*actions, run_time=DEFAULT_ANIMATION_RUNTIME)
        
        # Clear the buffer
        self.buffer.clear()
        
        # Record timestamp for the web player
        self.time_stamps.append(self.scene.current_scene_time + ELEMENT_DISPLAY_WAIT_TIME / 2)
        self.scene.wait(ELEMENT_DISPLAY_WAIT_TIME)
    
    def get_time_stamps(self):
        """
        Get the timestamps of all animations.
        
        Returns:
            List of timestamps in seconds
        """
        return self.time_stamps


class PresentationRenderer:
    """
    Renders a presentation from InputLines.
    """
    
    def __init__(self, scene):
        """
        Initialize a new presentation renderer.
        
        Args:
            scene: The scene to render in
        """
        self.scene = scene
        self.position = ElementPosition()
        self.animation_buffer = AnimationBuffer(scene)
    
    def render_line(self, line):
        """
        Render a line of content.
        
        Args:
            line: The line to render
        """
        elements = line.output_elements
        
        if len(elements) == 1:
            # Single element - left aligned
            element = elements[0]
            element.position_left_aligned(self.position.get_current_position())
            self.position.update_after_element(element)
            self.animation_buffer.add_element(element)
        else:
            # Multiple elements - distribute horizontally
            num_elements = len(elements)
            for i, element in enumerate(elements, 1):
                # Create a position for this element
                position = self.position.get_current_position()
                position.to_edge(LEFT, buff=0)
                position.shift(RIGHT * (position.get_edge_center(LEFT) - position.get_center()))
                position.shift(i * 2 * FRAME_X_RADIUS * RIGHT / (num_elements + 1))
                
                # Position and animate the element
                element.position_center_at(position)
                self.animation_buffer.add_element(element)
            
            # Update position to the bottom of the last element
            self.position.update_after_element(elements[-1])
    
    def get_shift_actions(self, line, position):
        """
        Get animations to shift elements in a line to a new position.
        
        Args:
            line: The line to shift
            position: The new position
            
        Returns:
            List of animations to play
        """
        elements = line.output_elements
        result = []
        
        if not elements:
            return []
        
        if len(elements) == 1:
            # Single element - left aligned
            element = elements[0]
            result.extend(element.get_shift_left_aligned_actions(position))
            
            # Update position
            element_copy = element.copy()
            element_copy.position_left_aligned(position)
            position.move_to(element_copy.get_bottom_position().get_edge_center(DOWN))
        else:
            # Multiple elements - distribute horizontally
            num_elements = len(elements)
            for i, element in enumerate(elements, 1):
                # Create a position for this element
                elem_position = position.copy()
                elem_position.to_edge(LEFT, buff=0)
                elem_position.shift(RIGHT * (elem_position.get_edge_center(LEFT) - elem_position.get_center()))
                elem_position.shift(i * 2 * FRAME_X_RADIUS * RIGHT / (num_elements + 1))
                
                # Get shift actions
                result.extend(element.get_shift_center_at_actions(elem_position))
            
            # Update position
            element_copy = elements[-1].copy()
            element_copy.position_center_at(elem_position)
            position.move_to(element_copy.get_bottom_position().get_edge_center(DOWN))
        
        # Add some vertical spacing
        position.shift(DOWN * 0.5)
        return result
    
    def render_presentation(self, lines):
        """
        Render a complete presentation.
        
        Args:
            lines: List of input lines to render
            
        Returns:
            List of timestamps for the web player
        """
        flush_index = 0  # Starting line to flush when using FLUSH
        
        # Initial wait
        self.scene.wait(ELEMENT_DISPLAY_WAIT_TIME)
        self.animation_buffer.time_stamps = [ELEMENT_DISPLAY_WAIT_TIME / 2]  # Initial timestamp
        
        for line in lines:
            if line.is_content_line():
                # Render content line
                self.render_line(line)
            else:
                # Process command line
                elements = line.input_elements
                if not elements:
                    raise SanimParseError("Empty line")
                if len(elements) > 1:
                    raise SanimParseError("More than one command in a line")
                
                element = elements[0]
                if element.keyword == 'FLUSH':
                    # Flush command
                    self.animation_buffer.flush()  # Flush any leftover animations
                    
                    # Parse flush line number (if empty, use the current line)
                    try:
                        if element.content.strip():
                            flush_line_num = int(element.content)
                        else:
                            flush_line_num = line.line_num
                    except ValueError:
                        raise SanimParseError(f"Invalid flush line number: {element.content}")
                    
                    current_line_num = line.line_num
                    if flush_line_num > current_line_num:
                        raise SanimParseError("Cannot flush beyond the current line")
                    
                    # Collect fade out animations for lines to be flushed
                    fade_out_actions = []
                    while flush_index < len(lines) and lines[flush_index].line_num < flush_line_num:
                        if lines[flush_index].is_content_line():
                            fade_out_actions.extend(lines[flush_index].get_fade_out_actions())
                        flush_index += 1
                    
                    # Reset position to top
                    self.position.reset_to_top()
                    
                    # Collect shift animations for lines to be kept
                    shift_actions = []
                    i = flush_index
                    current_position = self.position.get_current_position()
                    while i < len(lines) and lines[i].line_num < current_line_num:
                        shift_actions.extend(self.get_shift_actions(
                            lines[i], current_position))
                        i += 1
                    
                    # Play flush animations
                    if fade_out_actions or shift_actions:
                        self.scene.play(
                            *fade_out_actions, *shift_actions, 
                            run_time=FLUSH_ANIMATION_RUNTIME
                        )
                    
                    # Record timestamp and wait
                    self.animation_buffer.time_stamps.append(
                        self.scene.current_scene_time + FLUSH_DISPLAY_WAIT_TIME / 2
                    )
                    self.scene.wait(FLUSH_DISPLAY_WAIT_TIME)
                else:
                    raise SanimParseError(f"Unknown command: {element.keyword}")
        
        # Flush any remaining animations
        self.animation_buffer.flush()
        
        return self.animation_buffer.get_time_stamps()


class Sanim(Scene):
    """
    Main Sanim scene class for rendering presentations.
    """
    
    CONFIG = {
        "camera_config": {"background_color": BACKGROUND_COLOR}
    }
    
    def construct(self):
        """Construct the scene for the presentation."""
        try:
            # Read the source file path from the auxiliary file
            with open(SANIM_AUX_FILE, "r") as sanim_file:
                source_file = sanim_file.read().strip()
            
            # Parse the input file
            lines = InputParser.parse_file(source_file)
            print("Finished parsing")
            
            # Render the presentation
            renderer = PresentationRenderer(self)
            time_stamps = renderer.render_presentation(lines)
            
            # Save timestamp data for the web player
            self._save_web_player_data(source_file, time_stamps)
            
        except SanimParseError as e:
            print(f"Error parsing input: {str(e)}")
            sys.exit(1)
        except SanimRenderError as e:
            print(f"Error rendering presentation: {str(e)}")
            sys.exit(1)
        except Exception as e:
            import traceback
            print(f"Unexpected error: {str(e)}")
            traceback.print_exc()
            sys.exit(1)
    
    def _save_web_player_data(self, source_file, time_stamps):
        """
        Save data for the web player.
        
        Args:
            source_file: Path to the source file
            time_stamps: List of timestamps
        """
        try:
            # Get source directory
            source_folder = os.path.dirname(os.path.abspath(source_file))
            
            # Save timestamps
            web_info_file = os.path.join(source_folder, SANIM_TIME_STAMPS_FILE)
            with open(web_info_file, 'w') as web_file:
                web_file.write(f"var timeStamps = {[round(t, 4) for t in time_stamps]}\n")
            
            # Copy HTML template
            source_html = os.path.join(self._get_main_manim_dir(), SANIM_HTML_FILE)
            dest_html = os.path.join(source_folder, SANIM_LOCAL_HTML_FILE)
            try:
                shutil.copy2(source_html, dest_html)
            except Exception as e:
                print(f"Error copying HTML template: {e}")
                try:
                    # Attempt to clean up
                    os.remove(dest_html)
                except Exception:
                    pass
        except Exception as e:
            print(f"Error saving web player data: {e}")
    
    def _get_main_manim_dir(self):
        """
        Get the main manim directory.
        
        Returns:
            Path to the main manim directory
        """
        # Find the directory containing the module
        # This is the directory containing sanim_refactored.py
        module_dir = os.path.dirname(os.path.abspath(__file__))
        return module_dir


# Utility functions for compatibility with the original sanim.py

def get_sanim_source_dir():
    """
    Get the directory containing the sanim source file.
    
    Returns:
        Path to the sanim source directory
    """
    with open(SANIM_AUX_FILE, "r") as sanim_file:
        source_file = sanim_file.read().strip()
    return os.path.dirname(os.path.abspath(source_file))


def get_main_manim_dir():
    """
    Get the main manim directory.
    
    Returns:
        Path to the main manim directory
    """
    # Find the directory containing the module
    module_dir = os.path.dirname(os.path.abspath(__file__))
    return module_dir
