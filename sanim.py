#!/usr/bin/env python

"""
Sanim is a tool to create animated presentations from simple text files.
It parses a specific syntax and converts it into manim animations.

Usage:
    ./sanim.py <presentation_file> [options]

Options:
    -l             Use low quality (faster rendering)
    -m             Use medium quality
    -p             Preview in low quality 
    -s             Show and save picture of last frame
    -o <filename>  Write to a different filename
"""

import os
import sys
import shutil
import argparse

# Import manim components
from manim_engine.big_ol_pile_of_manim_imports import *
from manim_engine.constants import *

# Import utility modules
from util.exceptions import (SanimParseError, SanimRenderError)

# Import parser and element components
from util.parsing import InputParser
from util.rendering import PresentationRenderer

# Constants for presentation styling
BACKGROUND_COLOR = "#e6f3ff"
DEFINITION_COLOR = "#991f00"

# File path constants
SANIM_AUX_FILE = 'manim_engine' + os.sep + 'sanim_flag_AUTOGENERATED.txt'
SANIM_HTML_FILE = "sanim_interactive.html"
SANIM_LOCAL_HTML_FILE = "sanim_interactive_AUTOGENERATED.html"
SANIM_VIDEO_FILE = "vid"  # .mp4 extension is added automatically
SANIM_TIME_STAMPS_FILE = "time_stamps_AUTOGENERATED.js"

class Sanim(Scene):
    """
    Main Sanim scene class for rendering presentations.
    """
    
    CONFIG = {
        "camera_config": {"background_color": BACKGROUND_COLOR}
    }
    
    def construct(self):
        """Construct the scene for the presentation."""
        try:
            # Read the source file path from the auxiliary file
            with open(SANIM_AUX_FILE, "r") as sanim_file:
                source_file = sanim_file.read().strip()
            
            # Parse the input file
            lines = InputParser.parse_file(source_file)
            print("Finished parsing")
            
            # Render the presentation
            renderer = PresentationRenderer(self)
            time_stamps = renderer.render_presentation(lines)
            
            # Save timestamp data for the web player
            self._save_web_player_data(source_file, time_stamps)
            
        except SanimParseError as e:
            print(f"Error parsing input: {str(e)}")
            sys.exit(1)
        except SanimRenderError as e:
            print(f"Error rendering presentation: {str(e)}")
            sys.exit(1)
        except Exception as e:
            import traceback
            print(f"Unexpected error: {str(e)}")
            traceback.print_exc()
            sys.exit(1)
    
    def _save_web_player_data(self, source_file, time_stamps):
        """
        Save data for the web player.
        
        Args:
            source_file: Path to the source file
            time_stamps: List of timestamps
        """
        try:
            # Get source directory
            source_folder = os.path.dirname(os.path.abspath(source_file))
            
            # Save timestamps
            web_info_file = os.path.join(source_folder, SANIM_TIME_STAMPS_FILE)
            with open(web_info_file, 'w') as web_file:
                web_file.write(f"var timeStamps = {[round(t, 4) for t in time_stamps]}\n")
            
            # Copy HTML template
            source_html = os.path.join(self._get_main_manim_dir(), SANIM_HTML_FILE)
            dest_html = os.path.join(source_folder, SANIM_LOCAL_HTML_FILE)
            try:
                shutil.copy2(source_html, dest_html)
            except Exception as e:
                print(f"Error copying HTML template: {e}")
                try:
                    # Attempt to clean up
                    os.remove(dest_html)
                except Exception:
                    pass
        except Exception as e:
            print(f"Error saving web player data: {e}")
    
    def _get_main_manim_dir(self):
        """
        Get the main manim directory.
        
        Returns:
            Path to the main manim directory
        """
        # Find the directory containing the module
        # This is the directory containing sanim_refactored.py
        module_dir = os.path.dirname(os.path.abspath(__file__))
        return module_dir


# Utility functions for compatibility with the original sanim.py

def get_sanim_source_dir():
    """
    Get the directory containing the sanim source file.
    
    Returns:
        Path to the sanim source directory
    """
    with open(SANIM_AUX_FILE, "r") as sanim_file:
        source_file = sanim_file.read().strip()
    return os.path.dirname(os.path.abspath(source_file))


def get_main_manim_dir():
    """
    Get the main manim directory.
    
    Returns:
        Path to the main manim directory
    """
    # Find the directory containing the module
    module_dir = os.path.dirname(os.path.abspath(__file__))
    return module_dir


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="Sanim - Slide Animation Tool")
    
    parser.add_argument("presentation_file", help="Path to the Sanim presentation file")
    parser.add_argument("-p", "--preview", action="store_true", help="Preview in low quality")
    parser.add_argument("-w", "--write_to_movie", action="store_true", help="Write to movie file")
    parser.add_argument("-s", "--show_last_frame", action="store_true", help="Show and save picture of last frame")
    parser.add_argument("-l", "--low_quality", action="store_true", help="Use low quality (faster rendering)")
    parser.add_argument("-m", "--medium_quality", action="store_true", help="Use medium quality")
    parser.add_argument("-g", "--save_pngs", action="store_true", help="Save PNG sequence")
    parser.add_argument("-f", "--show_file_in_finder", action="store_true", help="Show file in finder when done")
    parser.add_argument("-t", "--transparent", action="store_true", help="Use transparency")
    parser.add_argument("-q", "--quiet", action="store_true", help="Don't print progress")
    parser.add_argument("-o", "--output_name", help="Write to a different filename")
    parser.add_argument("-n", "--start_at_animation_number", help="Start at specific animation number")
    parser.add_argument("-r", "--resolution", help="Specify resolution (height or height,width)")
    
    return parser.parse_args()


def get_configuration():
    """Get configuration based on command line arguments."""
    args = parse_args()
    
    # Write the presentation file path to the auxiliary file
    with open(SANIM_AUX_FILE, "w") as sanim_aux_file:
        sanim_aux_file.write(args.presentation_file)
    
    # Process output name
    if args.output_name is not None:
        output_name_root, output_name_ext = os.path.splitext(args.output_name)
        expected_ext = '.png' if args.show_last_frame else '.mp4'
        if output_name_ext not in ['', expected_ext]:
            print(f"WARNING: The output will be to (doubly-dotted) {output_name_root}{expected_ext}")
            output_name = args.output_name
        else:
            output_name = output_name_root
    else:
        output_name = args.output_name
    
    # Set up configuration
    config = {
        "open_video_upon_completion": args.preview,
        "show_file_in_finder": args.show_file_in_finder,
        "write_to_movie": args.write_to_movie or not args.show_last_frame,
        "show_last_frame": args.show_last_frame,
        "save_pngs": args.save_pngs,
        "saved_image_mode": "RGBA" if args.transparent else "RGB",
        "movie_file_extension": ".mov" if args.transparent else ".mp4",
        "quiet": args.quiet,
        "ignore_waits": args.preview,
        "output_name": output_name,
        "start_at_animation_number": args.start_at_animation_number,
        "end_at_animation_number": None,
    }
    
    # Camera configuration
    config["camera_config"] = {}
    if args.low_quality:
        config["camera_config"].update(LOW_QUALITY_CAMERA_CONFIG)
        config["frame_duration"] = LOW_QUALITY_FRAME_DURATION
    elif args.medium_quality:
        config["camera_config"].update(MEDIUM_QUALITY_CAMERA_CONFIG)
        config["frame_duration"] = MEDIUM_QUALITY_FRAME_DURATION
    else:
        config["camera_config"].update(PRODUCTION_QUALITY_CAMERA_CONFIG)
        config["frame_duration"] = PRODUCTION_QUALITY_FRAME_DURATION
    
    # Resolution configuration
    if args.resolution:
        if "," in args.resolution:
            height_str, width_str = args.resolution.split(",")
            height = int(height_str)
            width = int(width_str)
        else:
            height = int(args.resolution)
            width = int(16 * height / 9)
        config["camera_config"].update({
            "pixel_height": height,
            "pixel_width": width,
        })
    
    # If rendering a transparent image/movie, make sure the scene has background opacity of 0
    if args.transparent:
        config["camera_config"]["background_opacity"] = 0
    
    # Arguments related to skipping
    stan = config["start_at_animation_number"]
    if stan is not None:
        if "," in stan:
            start, end = stan.split(",")
            config["start_at_animation_number"] = int(start)
            config["end_at_animation_number"] = int(end)
        else:
            config["start_at_animation_number"] = int(stan)
    
    config["skip_animations"] = any([
        config["show_last_frame"] and not config["write_to_movie"],
        config["start_at_animation_number"],
    ])
    
    return config


def main():
    """Main entry point function."""
    try:
        config = get_configuration()
        
        # Prepare scene kwargs
        scene_kwargs = dict([
            (key, config[key])
            for key in [
                "camera_config",
                "frame_duration",
                "skip_animations",
                "write_to_movie",
                "save_pngs",
                "movie_file_extension",
                "start_at_animation_number",
                "end_at_animation_number",
            ]
        ])
        
        scene_kwargs["name"] = config["output_name"]
        if config["save_pngs"]:
            print("We are going to save a PNG sequence as well...")
            scene_kwargs["save_pngs"] = True
            scene_kwargs["pngs_mode"] = config["saved_image_mode"]
        
        # Create and run scene
        scene = Sanim(**scene_kwargs)
        
        # Handle scene output options
        if config["quiet"]:
            curr_stdout = sys.stdout
            sys.stdout = open(os.devnull, "w")
        
        if config["show_last_frame"]:
            scene.save_image(mode=config["saved_image_mode"])
        
        open_file = any([
            config["show_last_frame"],
            config["open_video_upon_completion"],
            config["show_file_in_finder"]
        ])
        
        if open_file:
            commands = ["open"]
            if (platform.system() == "Linux"):
                commands = ["xdg-open"]
            elif (platform.system() == "Windows"):
                commands = ["start"]
            
            if config["show_file_in_finder"]:
                commands.append("-R")
            
            if config["show_last_frame"]:
                file_path = scene.get_image_file_path()
            else:
                file_path = scene.get_movie_file_path()
            
            commands.append(file_path)
            
            try:
                FNULL = open(os.devnull, 'w')
                result = sp.call(commands, stdout=FNULL, stderr=sp.STDOUT, shell=True)
                FNULL.close()
            except Exception as e:
                print(f"Error opening file: {e}")
        
        if config["quiet"]:
            sys.stdout.close()
            sys.stdout = curr_stdout
        
        return 0
    
    except SanimParseError as e:
        print(f"Error parsing input: {str(e)}")
        return 1
    except SanimRenderError as e:
        print(f"Error rendering presentation: {str(e)}")
        return 1
    except Exception as e:
        import traceback
        print(f"Unexpected error: {str(e)}")
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    import platform
    import subprocess as sp
    sys.exit(main())
